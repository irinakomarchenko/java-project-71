Проект — это утилита для сравнения двух конфигурационных файлов (JSON или YAML) и вывода разницы между ними. Весь цикл работы программы можно разбить на несколько этапов:

1. Запуск программы
Программа запускается через командную строку с использованием Picocli, как указано в классе App. Пользователь указывает два файла и опционально формат вывода (по умолчанию используется формат stylish).

Команда для запуска:



./build/install/app/bin/app file1.json file2.json --format plain


2. Обработка аргументов
Класс App обрабатывает аргументы командной строки с помощью библиотеки Picocli. Он принимает два обязательных аргумента — пути к файлам для сравнения, и 
опциональный аргумент — формат вывода.



@Command(name = "gendiff", mixinStandardHelpOptions = true, version = "gendiff 1.0",
        description = "Compares two configuration files and shows a difference.")
public class App implements Callable<Integer> {
    @Option(names = {"-f", "--format"}, description = "output format [default: ${DEFAULT-VALUE}]",
            defaultValue = "stylish")
    private String format;

    @Parameters(index = "0", description = "The first file to compare.")
    private String filePath1;

    @Parameters(index = "1", description = "The second file to compare.")
    private String filePath2;
}


3. Вызов метода Differ.generate
После того, как аргументы были обработаны, вызывается метод Differ.generate, который выполняет основные шаги по сравнению файлов.


public Integer call() {
    if (filePath1 == null || filePath2 == null) {
        System.out.println("Please provide two file paths for comparison.");
        return 1;
    }

    try {
        String result = Differ.generate(filePath1, filePath2, format);
        System.out.println(result);
        return 0;
    } catch (IOException e) {
        System.err.println("Error reading files: " + e.getMessage());
        return 1;
    } catch (Exception e) {
        System.err.println("Error: " + e.getMessage());
        return 1;
    }
}


4. Чтение и парсинг файлов
Метод Differ.generate читает содержимое файлов и определяет их расширения, после чего парсит их в структуру данных Map<String, Object>.


public static String generate(String filepath1, String filepath2, String format) throws Exception {
    String file1Content = readFileToString(filepath1);
    String file2Content = readFileToString(filepath2);

    String fileExtension1 = getFileExtension(filepath1);
    String fileExtension2 = getFileExtension(filepath2);

    Map<String, Object> map1 = Parser.parse(file1Content, fileExtension1);
    Map<String, Object> map2 = Parser.parse(file2Content, fileExtension2);

    List<DiffProperty> diff = TreeDiffer.compareData(map1, map2);

    return format(format, diff);
	
	
}
5. Парсер Parser.parse
Парсер использует ObjectMapper для преобразования строкового содержимого файлов в карты (Map). Он поддерживает как JSON, так и YAML файлы.


public class Parser {
    public static Map<String, Object> parse(String content, String fileExtension) throws IOException {
        ObjectMapper objectMapper = fileExtension.equals("yaml") || fileExtension.equals("yml") ?
                new ObjectMapper(new YAMLFactory()) : new ObjectMapper();
        return objectMapper.readValue(content, Map.class);
    }
}


6. Сравнение данных TreeDiffer.compareData
Этот метод сравнивает два парсированных файла, создавая список объектов DiffProperty, каждый из которых описывает одно отличие (добавленный, удаленный, 
измененный или неизмененный ключ).


public class TreeDiffer {
    public static List<DiffProperty> compareData(Map<String, Object> map1, Map<String, Object> map2) {
        List<DiffProperty> diff = new ArrayList<>();
        Set<String> allKeys = new TreeSet<>(map1.keySet());
        allKeys.addAll(map2.keySet());

        for (String key : allKeys) {
            if (!map1.containsKey(key)) {
                diff.add(new DiffProperty(key, null, map2.get(key), DiffProperty.DiffType.ADDED));
            } else if (!map2.containsKey(key)) {
                diff.add(new DiffProperty(key, map1.get(key), null, DiffProperty.DiffType.REMOVED));
            } else if (!map1.get(key).equals(map2.get(key))) {
                diff.add(new DiffProperty(key, map1.get(key), map2.get(key), DiffProperty.DiffType.CHANGED));
            } else {
                diff.add(new DiffProperty(key, map1.get(key), map2.get(key), DiffProperty.DiffType.UNCHANGED));
            }
        }

        return diff;
    }
}


7. Форматирование результата
Результат сравнения форматируется в зависимости от выбранного пользователем формата. Поддерживаются форматы stylish, json и plain. Форматер преобразует
 список DiffProperty в строковое представление.

Пример форматера StylishFormatter:


public class StylishFormatter implements Formatter {
    @Override
    public String format(List<DiffProperty> diff) {
        StringBuilder result = new StringBuilder("{\n");
        for (DiffProperty property : diff) {
            switch (property.getType()) {
                case ADDED -> result.append("  + ").append(property.getKey())
                        .append(": ").append(valueToString(property.getNewValue())).append("\n");
                case REMOVED -> result.append("  - ").append(property.getKey())
                        .append(": ").append(valueToString(property.getOldValue())).append("\n");
                case CHANGED -> {
                    result.append("  - ").append(property.getKey())
                            .append(": ").append(valueToString(property.getOldValue())).append("\n");
                    result.append("  + ").append(property.getKey())
                            .append(": ").append(valueToString(property.getNewValue())).append("\n");
                }
                case UNCHANGED -> result.append("    ").append(property.getKey())
                        .append(": ").append(valueToString(property.getOldValue())).append("\n");
                default -> throw new IllegalArgumentException("Unexpected property type: " + property.getType());
            }
        }
        result.append("}");
        return result.toString();
    }

    private String valueToString(Object value) {
        if (value instanceof Map || value instanceof List) {
            return value.toString();
        }
        return String.valueOf(value);
    }
}
8. Вывод результата
Форматированный результат выводится на экран.

Полный цикл работы программы:
Запуск программы с аргументами (файлы и формат).
Обработка аргументов с помощью Picocli.
Чтение содержимого файлов.
Парсинг содержимого файлов в карты (Map).
Сравнение данных из двух карт, создание списка DiffProperty.
Форматирование списка DiffProperty в строковое представление в соответствии с выбранным форматом.
Вывод результата на экран.
Таким образом, проект предоставляет удобный способ сравнения конфигурационных файлов с поддержкой различных форматов и вложенных 
структур, обеспечивая гибкость и расширяемость.


Изменим ваш класс Parser, чтобы исправить это:

Импортируем TypeReference из Jackson для указания типа.
Используем типизированный вариант Map в методе readValue.
Вот как это можно сделать:



package hexlet.code;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;

import java.io.IOException;
import java.util.Map;

public class Parser {
    public static Map<String, Object> parse(String content, String fileExtension) throws IOException {
        ObjectMapper objectMapper = fileExtension.equals("yaml") || fileExtension.equals("yml") ?
                new ObjectMapper(new YAMLFactory()) : new ObjectMapper();
        return objectMapper.readValue(content, new TypeReference<Map<String, Object>>() {});
    }
}
Что изменилось:

Мы добавили импорт TypeReference.
В методе readValue указали тип Map<String, Object> с использованием new TypeReference<Map<String, Object>>() {}.
Теперь ваш код будет типобезопасным и компилятор не должен выдавать предупреждения о необработанных типах.

После внесения этих изменений выполните сборку проекта снова и проверьте, исчезли ли предупреждения компилятора. Если всё в порядке, вы сможете продолжить работу над проектом.



