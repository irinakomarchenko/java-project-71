APP

package hexlet.code;

import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

import java.io.IOException;
import java.util.concurrent.Callable;

@Command(name = "gendiff", mixinStandardHelpOptions = true, version = "gendiff 1.0",
        description = "Compares two configuration files and shows a difference.")
public class App implements Callable<Integer> {

    @Option(names = {"-f", "--format"}, description = "output format [default: ${DEFAULT-VALUE}]",
            defaultValue = "stylish")
    private String format;

    @Parameters(index = "0", description = "The first file to compare.")
    private String filePath1;

    @Parameters(index = "1", description = "The second file to compare.")
    private String filePath2;

    public static void main(String[] args) {
        int exitCode = new CommandLine(new App()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call() {
        if (filePath1 == null || filePath2 == null) {
            System.out.println("Please provide two file paths for comparison.");
            return 1;
        }

        try {
            String result = Differ.generate(filePath1, filePath2, format);
            System.out.println(result);
            return 0;
        } catch (IOException e) {
            System.err.println("Error reading files: " + e.getMessage());
            return 1;
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            return 1;
        }
    }
}

Differ

package hexlet.code;

import hexlet.code.formatters.Formatter;
import hexlet.code.formatters.JsonFormatter;
import hexlet.code.formatters.PlainFormatter;
import hexlet.code.formatters.StylishFormatter;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;

public class Differ {
    private static final Formatter STYLISH_FORMATTER = new StylishFormatter();
    private static final Formatter JSON_FORMATTER = new JsonFormatter();
    private static final Formatter PLAIN_FORMATTER = new PlainFormatter();

    public static String generate(String filepath1, String filepath2, String format) throws Exception {
        String file1Content = readFileToString(filepath1);
        String file2Content = readFileToString(filepath2);

        String fileExtension1 = getFileExtension(filepath1);
        String fileExtension2 = getFileExtension(filepath2);

        Map<String, Object> map1 = Parser.parse(file1Content, fileExtension1);
        Map<String, Object> map2 = Parser.parse(file2Content, fileExtension2);

        List<DiffProperty> diff = TreeDiffer.compareData(map1, map2);

        return format(format, diff);
    }

    public static String generate(String filepath1, String filepath2) throws Exception {
        return generate(filepath1, filepath2, "stylish");
    }

    public static String readFileToString(String filepath) throws IOException {
        Path path = Path.of(filepath).toAbsolutePath().normalize();
        return Files.readString(path);
    }

    private static String getFileExtension(String filepath) {
        String fullPath = Path.of(filepath).toAbsolutePath().normalize().toString();
        int index = fullPath.lastIndexOf('.');
        return index == -1 ? null : fullPath.substring(index + 1).toLowerCase();
    }

    private static String format(String format, List<DiffProperty> diff) throws Exception {
        switch (format) {
            case "stylish":
                return STYLISH_FORMATTER.format(diff);
            case "json":
                return JSON_FORMATTER.format(diff);
            case "plain":
                return PLAIN_FORMATTER.format(diff);
            default:
                throw new IllegalArgumentException("Unsupported format: " + format);
        }
    }
}

DiffProperty

package hexlet.code;

public class DiffProperty {
    private final String key;
    private final Object oldValue;
    private final Object newValue;
    private final DiffType type;

    public DiffProperty(String key, Object oldValue, Object newValue, DiffType type) {
        this.key = key;
        this.oldValue = oldValue;
        this.newValue = newValue;
        this.type = type;
    }

    public DiffProperty(String key, Object value, DiffType type) {
        this(key, value, null, type);
    }

    public String getKey() {
        return key;
    }

    public Object getOldValue() {
        return oldValue;
    }

    public Object getNewValue() {
        return newValue;
    }

    public DiffType getType() {
        return type;
    }
}

DiffType


package hexlet.code;

public enum DiffType {
    ADDED, REMOVED, CHANGED, UNCHANGED
}

Parser

package hexlet.code;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;

import java.io.IOException;
import java.util.Map;

public class Parser {
    @SuppressWarnings("unchecked")
    public static Map<String, Object> parse(String content, String extension) throws IOException {
        ObjectMapper objectMapper;
        if ("json".equals(extension)) {
            objectMapper = new ObjectMapper();
        } else if ("yaml".equals(extension) || "yml".equals(extension)) {
            objectMapper = new ObjectMapper(new YAMLFactory());
        } else {
            throw new IllegalArgumentException("Unsupported file format: " + extension);
        }
        return objectMapper.readValue(content, Map.class);
    }
}


TreeDiffer

package hexlet.code;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.ArrayList;


public class TreeDiffer {
    public static List<DiffProperty> compareData(Map<String, Object> map1, Map<String, Object> map2) {
        Set<String> keys = new TreeSet<>(map1.keySet());
        keys.addAll(map2.keySet());
        List<DiffProperty> diff = new ArrayList<>();

        for (String key : keys) {
            if (!map1.containsKey(key)) {
                diff.add(new DiffProperty(key, null, map2.get(key), DiffType.ADDED));
            } else if (!map2.containsKey(key)) {
                diff.add(new DiffProperty(key, map1.get(key), null, DiffType.REMOVED));
            } else {
                Object value1 = map1.get(key);
                Object value2 = map2.get(key);
                if (value1.equals(value2)) {
                    diff.add(new DiffProperty(key, value1, value2, DiffType.UNCHANGED));
                } else {
                    diff.add(new DiffProperty(key, value1, value2, DiffType.CHANGED));
                }
            }
        }
        return diff;
    }
}



Formatter

package hexlet.code.formatters;

import hexlet.code.DiffProperty;

import java.util.List;

public interface Formatter {
    String format(List<DiffProperty> diff) throws Exception;
}


JsonFormatter

package hexlet.code.formatters;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import hexlet.code.DiffProperty;

import java.util.List;

public class JsonFormatter implements Formatter {
    @Override
    public String format(List<DiffProperty> diff) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        return objectMapper.writeValueAsString(diff);
    }
}


PlainFormatter

package hexlet.code.formatters;

import hexlet.code.DiffProperty;

import java.util.List;

public class PlainFormatter implements Formatter {
    @Override
    public String format(List<DiffProperty> diff) {
        StringBuilder result = new StringBuilder();
        for (DiffProperty property : diff) {
            switch (property.getType()) {
                case ADDED -> result.append("Property '").append(property.getKey())
                        .append("' was added with value: ").append(formatValue(property.getNewValue())).append("\n");
                case REMOVED -> result.append("Property '").append(property.getKey()).append("' was removed")
                        .append("\n");
                case CHANGED -> result.append("Property '").append(property.getKey())
                        .append("' was updated. From ").append(formatValue(property.getOldValue()))
                        .append(" to ").append(formatValue(property.getNewValue())).append("\n");
                case UNCHANGED -> {
                    // Do nothing for unchanged properties
                }
                default -> throw new IllegalArgumentException("Unexpected property type: " + property.getType());
            }
        }
        return result.toString().trim();
    }

    private String formatValue(Object value) {
        if (value == null) {
            return "null";
        }
        return value instanceof String ? "'" + value + "'" : String.valueOf(value);
    }
}


StylishFormatter

package hexlet.code.formatters;

import hexlet.code.DiffProperty;

import java.util.List;

public class StylishFormatter implements Formatter {
    @Override
    public String format(List<DiffProperty> diff) {
        StringBuilder result = new StringBuilder("{\n");
        for (DiffProperty property : diff) {
            switch (property.getType()) {
                case ADDED -> result.append("  + ").append(property.getKey()).append(": ").append(property
                        .getNewValue()).append("\n");
                case REMOVED -> result.append("  - ").append(property.getKey()).append(": ").append(property
                        .getOldValue()).append("\n");
                case CHANGED -> {
                    result.append("  - ").append(property.getKey()).append(": ").append(property.getOldValue())
                            .append("\n");
                    result.append("  + ").append(property.getKey()).append(": ").append(property.getNewValue())
                            .append("\n");
                }
                case UNCHANGED -> result.append("    ").append(property.getKey()).append(": ").append(property
                        .getOldValue()).append("\n");
                default -> throw new IllegalArgumentException("Unexpected property type: " + property.getType());
            }
        }
        result.append("}");
        return result.toString();
    }
}


DifferTest

package hexlet.code;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.jupiter.api.Assertions.assertEquals;

class DifferTest {

    @ParameterizedTest
    @CsvSource({
        "src/test/resources/file1.yml, src/test/resources/file2.yml, src/test/resources/expectedStylish.txt, stylish",
        "src/test/resources/file1.yml, src/test/resources/file2.yml, src/test/resources/expectedPlain.txt, plain",
        "src/test/resources/file1.yml, src/test/resources/file2.yml, src/test/resources/expectedJson.txt, json"
    })
    void testGenerate(String filepath1, String filepath2, String expectedResultFilepath, String format)
            throws Exception {
        String expectedResult = normalizeString(Files.readString(Paths.get(expectedResultFilepath)));
        String actualResult = normalizeString(Differ.generate(filepath1, filepath2, format));

        assertEquals(expectedResult, actualResult);
    }

    private String normalizeString(String input) {
        return input.trim().replaceAll("\\r\\n", "\n").replaceAll("\\r", "\n");
    }
}



STEP 7

$ ./build/install/app/bin/app src/test/resources/file1.yml src/test/resources/file2.yml



	
	build gradle.kts
	
	
	import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id("java")
    id("application")
    id("checkstyle")
    id("io.freefair.lombok") version "8.6"
    id("com.github.ben-manes.versions") version "0.50.0"
    id("com.github.johnrengelman.shadow") version "8.1.1"
    id("jacoco")
}

group = "hexlet.code"
version = "1.0-SNAPSHOT"

application {mainClass.set("hexlet.code.App") }

tasks.named<JavaExec>("run") {
    args = listOf("")
}

repositories {
    mavenCentral()
}

dependencies {
    testImplementation(platform("org.junit:junit-bom:5.10.0"))
    testImplementation("org.junit.jupiter:junit-jupiter")
    implementation("info.picocli:picocli:4.7.0")
    implementation("org.apache.commons:commons-lang3:3.14.0")
    implementation("org.apache.commons:commons-collections4:4.4")
    implementation("com.fasterxml.jackson.core:jackson-databind:2.13.4.1")
    implementation("com.fasterxml.jackson.core:jackson-core:2.13.0")
    implementation("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.13.0")
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("com.fasterxml.jackson.core:jackson-annotations")
    implementation("com.fasterxml.jackson.core:jackson-core")
    testImplementation(platform("org.junit:junit-bom:5.10.1"))
    testImplementation("org.junit.jupiter:junit-jupiter")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.7.0")
}

tasks.test {
    useJUnitPlatform()
    useJUnitPlatform()
    testLogging {
        exceptionFormat = TestExceptionFormat.FULL
        events = mutableSetOf(TestLogEvent.FAILED, TestLogEvent.PASSED, TestLogEvent.SKIPPED)
        // showStackTraces = true
        // showCauses = true
        showStandardStreams = true
    }
}

jacoco {
    toolVersion = "0.8.11"
}

tasks.jacocoTestReport {
    reports {
        xml.required = true
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir("jacocoHtml")
    }
